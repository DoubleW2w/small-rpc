---
title: 11.ä½¿ç”¨CGLIBè°ƒç”¨çœŸå®æ–¹æ³•çš„å®ç°
date: 2024/6/09

---

## ğŸˆS

> æˆ‘ä¸æƒ³ç”¨åå°„æŠ€æœ¯è°ƒç”¨çœŸå®æ–¹æ³•ï¼Œæ€ä¹ˆåŠï¼Ÿ

ä¸Šä¸€ç« èŠ‚å®ç°äº†ä½¿ç”¨åå°„æŠ€æœ¯å»è°ƒç”¨çœŸå®æ–¹æ³•ï¼Œä½†æœåŠ¡æä¾›è€…å¦‚æœåªèƒ½å¤Ÿä½¿ç”¨ Java çš„åå°„æŠ€æœ¯è°ƒç”¨çœŸå®æ–¹æ³•ï¼Œä¸€æ–¹é¢ä¼šé™åˆ¶äº†æ¡†æ¶äº†æ‰©å±•ï¼Œä¸€æ–¹é¢ä¹Ÿä¸åˆ©äºæ¡†æ¶çš„æ€§èƒ½ä¼˜åŒ–ã€‚

## ğŸˆT

> æ”¯æŒå®ç° cgLib æ–¹å¼è°ƒç”¨çœŸå®æ–¹æ³•

åœ¨å¯åŠ¨æœåŠ¡æä¾›è€…æ—¶ï¼Œå¯ä»¥æ ¹æ®å®é™…éœ€è¦é…ç½®ä½¿ç”¨ Java åå°„æŠ€æœ¯è°ƒç”¨çœŸå®æ–¹æ³•ï¼Œè¿˜æ˜¯ä½¿ç”¨ CGLib æŠ€æœ¯è°ƒç”¨çœŸå®æ–¹æ³•ã€‚

- æœåŠ¡æä¾›è€…é…ç½®è°ƒç”¨çœŸå®æ–¹æ³•çš„æ–¹å¼ï¼šJava åå°„ã€Cglibã€‚

- æœåŠ¡æä¾›è€…åœ¨å¯åŠ¨åï¼Œä¼šè¯»å–å¯¹åº”çš„é…ç½®é¡¹ã€‚
- æ ¹æ®å¯¹åº”çš„é…ç½®é¡¹è·¯ç”±åˆ°ä½¿ç”¨ Java åå°„è¿˜æ˜¯ CGLib æ¥è°ƒç”¨çœŸå®æ–¹æ³•ã€‚

## ğŸˆA

```java
  @Test
  public void testRpcSingleServerScanner() {
    // æ‰«æRpcServiceæ³¨è§£ç±»
    RpcSingleServer rpcSingleServer =
        new RpcSingleServer("127.0.0.1:27880", "com.doublew2w.rpc.test", "cglib");
    // å¯åŠ¨æœåŠ¡å™¨
    rpcSingleServer.startNettyServer();
  }
```

æä¾›æ˜¯å“ªç§ç±»å‹çš„è°ƒç”¨çœŸå®æ–¹æ³•çš„æ–¹å¼

```java
@Slf4j
public class RpcProviderHandler extends SimpleChannelInboundHandler<RpcProtocol<RpcRequest>> {
    /** æœåŠ¡æä¾›è€… */
    private final Map<String, Object> handlerMap;

    /** è°ƒç”¨é‡‡ç”¨å“ªç§ç±»å‹è°ƒç”¨çœŸå®æ–¹æ³• */
    private final String reflectType;

    public RpcProviderHandler(Map<String, Object> handlerMap, String reflectType) {
        this.handlerMap = handlerMap;
        this.reflectType = reflectType;
    }

    //çœç•¥å…¶ä»–ä»£ç 
    private Object handle(RpcRequest request) throws Throwable {
        // çœç•¥å…¶ä»–ä»£ç 
        return invokeMethod(serviceBean, serviceClass, methodName, parameterTypes, parameters);
    }

    /** è°ƒç”¨æ–¹æ³• */
    private Object invokeMethod(
        Object serviceBean,
        Class<?> serviceClass,
        String methodName,
        Class<?>[] parameterTypes,
        Object[] parameters)
        throws Throwable {
        switch (this.reflectType) {
            case RpcConstants.REFLECT_TYPE_JDK: //jdk
                return this.invokeJDKMethod(
                    serviceBean, serviceClass, methodName, parameterTypes, parameters);
            case RpcConstants.REFLECT_TYPE_CGLIB: // cglib
                return this.invokeCGLibMethod(
                    serviceBean, serviceClass, methodName, parameterTypes, parameters);
            default:
                throw new IllegalArgumentException("not support reflect type");
        }
    }
    private Object invokeCGLibMethod(
        Object serviceBean,
        Class<?> serviceClass,
        String methodName,
        Class<?>[] parameterTypes,
        Object[] parameters)
        throws Throwable {
        // Cglib reflect
        log.info("use cglib reflect type invoke method...");
        FastClass serviceFastClass = FastClass.create(serviceClass);
        FastMethod serviceFastMethod = serviceFastClass.getMethod(methodName, parameterTypes);
        return serviceFastMethod.invoke(serviceBean, parameters);
    }

    private Object invokeJDKMethod(
        Object serviceBean,
        Class<?> serviceClass,
        String methodName,
        Class<?>[] parameterTypes,
        Object[] parameters)
        throws Throwable {
        log.info("Start invoking method...:");
        Method method = serviceClass.getMethod(methodName, parameterTypes);
        method.setAccessible(true);
        return method.invoke(serviceBean, parameters);
    }
}
```

<img src="https://doublew2w-myblogimages.oss-cn-hangzhou.aliyuncs.com/img/202406091615735.png"/>

## ğŸˆR

å¦‚ä½•ä½¿ç”¨ cglib æ¥è¿›è¡Œè°ƒç”¨çœŸå®æ–¹æ³•ã€‚

**æ–¹å¼ä¸€ï¼š** é€‚åˆé«˜æ•ˆåå°„è°ƒç”¨åœºæ™¯ï¼Œä¸ä¼šæ”¹å˜åŸå§‹ç±»çš„ç»“æ„ã€‚

```java
FastClass serviceFastClass = FastClass.create(ç±»ä¿¡æ¯);
FastMethod serviceFastMethod = serviceFastClass.getMethod(æ–¹æ³•å, å‚æ•°ç±»å‹åˆ—è¡¨);
return serviceFastMethod.invoke(serviceBean, parameters);
```



**æ–¹å¼äºŒï¼š** é€‚åˆåŠ¨æ€ä»£ç†å’Œ AOP åœºæ™¯ï¼Œé€šè¿‡åˆ›å»ºä»£ç†ç±»å®ä¾‹æ¥æ‹¦æˆªæ–¹æ³•è°ƒç”¨å¹¶æ·»åŠ è‡ªå®šä¹‰é€»è¾‘ã€‚

```java
import net.sf.cglib.proxy.Enhancer;
import net.sf.cglib.proxy.MethodInterceptor;
import net.sf.cglib.proxy.MethodProxy;

public class RealClass {
    public void doSomething() {
        System.out.println("æ‰§è¡ŒçœŸå®æ–¹æ³•");
    }
}

public class RealClassProxy implements MethodInterceptor {
    private Object target;

    public RealClassProxy(Object target) {
        this.target = target;
    }

    public Object getProxyInstance() {
        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(this.target.getClass());
        enhancer.setCallback(this);
        return enhancer.create();
    }

    @Override
    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
        System.out.println("æ–¹æ³•è°ƒç”¨å‰çš„å¤„ç†...");
        Object result = proxy.invokeSuper(obj, args);
        System.out.println("æ–¹æ³•è°ƒç”¨åçš„å¤„ç†...");
        return result;
    }

    public static void main(String[] args) {
        RealClass real = new RealClass();
        RealClassProxy proxy = new RealClassProxy(real);
        RealClass proxyInstance = (RealClass) proxy.getProxyInstance();
        proxyInstance.doSomething();
    }
}
```

