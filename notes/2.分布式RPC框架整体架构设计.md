## 整体架构

RPC 的英文全称是 **Remote Procedure Call**，翻译成中文就是远程过程调用，能够使开发人员像调用本地服务一样调用远程服务。在一个 RPC 框架中，可以分为「服务提供者」、「注册中心」、「服务消费者」、「监控中心」

<img src="https://doublew2w-myblogimages.oss-cn-hangzhou.aliyuncs.com/img/202406042137901.png"/>

在一次 RPC 调用过程中，它们的交互如下：

1. 「服务者提供者」启动后，将服务信息注册到「注册中心」—— 服务注册
2. 「服务消费者」启动后，会向「注册中心」订阅服务的地址。—— 服务订阅
3. 「注册中心」将相应的服务提供者信息推送给「服务消费者 —— 服务推送。
4. 「服务消费者」根据从注册中心获取的服务提供者信息，直接远程调用「服务提供者」的服务。
   1. 「服务消费者」的动态代理模块会将远程调用需要的 **接口名称**、**方法名称**、**方法参数类型列表**、**方法参数列表** 等信息序列化成二进制字节流，传输到服务提供者。
   2. 「服务提供者」接收到数据后，将二进制进行解码，反序列化成数据，调用对应的服务，将返回的响应信息进行编码，序列化成二进制字节流发送给「服务消费者」
   3. 「服务消费者」接收到「服务者提供者」的返回数据后，进行解码后继续后续的业务流程

<img src="https://doublew2w-myblogimages.oss-cn-hangzhou.aliyuncs.com/img/202406042154936.png"/>

5. 「服务提供者」和「服务消费者」在运行过程中，会将自身的状态和调用信息上报到「监控中心」。监控中心收集并处理这些信息，用于监控整个系统的运行状态，发现问题并及时报警。

## 技术点

### 服务注册与发现

<img src="https://doublew2w-myblogimages.oss-cn-hangzhou.aliyuncs.com/img/202406042210934.png"/>

###  网络通信协议

在 RPC 框架中，网络通信协议的实现越简单越好，尽可能减少数据编解码和在网络传输过程中的性能损耗。

### 序列化与反序列化

数据在网络上进行传输时，需要将原始数据采用编码方式 **序列化** 成二进制字节流在网络上传输，不管是服务提供者还是服务消费者接收到数据后，都需要将二进制字节流数据 **反序列化** 成原始数据。

### RPC 调用方式

同步调用（Sync）、异步调用（Future）、回调（Callback）、单向调用（Oneway）。

### 线程模型

一般情况下，在 RPC 框架中，线程模型会分为 IO 线程和业务线程。

- IO 线程主要用来负责事件轮询、数据的编解码，数据传输等功能。
- 将数据的处理或者业务处理放在业务线程中执行，以免阻塞 IO 线程。



Dubbo 提供了五种可配置的线程分发策略，也就是利用这五种策略分别确定了哪些逻辑在 IO 线程中执行，哪些逻辑在业务线程中执行。

<img src="https://doublew2w-myblogimages.oss-cn-hangzhou.aliyuncs.com/img/202406042216814.png"/>

###  动态代理

#### JDK 动态代理

JDK 动态代理在运行时可以动态生成代理对象，但是使用 JDK 动态代理时，代理对象必须实现一个接口，这是因为生成的代理对象继承了 Proxy 类

#### Cglib 动态代理

通过 ASM 字节码生成框架生成代理类

代理类的类型不受限制

生成的代理类会 **继承** 被代理类，要求被代理类不能使用 final 关键字修饰。

#### Javassist 和 ASM 

#### Byte Buddy

Byte Buddy 提供了更加方便的 API 来创建和修改 Java 的字节码，并且使用 Byte Buddy 时，不需要理解字节码的格式，性能也更加优越。



### 负载均衡

如何从多个服务提供者节点中选择一个进行远程调用呢？

- 轮询：**依次轮询** 服务提供者节点，并且不会考虑服务提供者节点的实际负载情况。
- 加权轮询：为每个服务提供者节点增加了权重系数，根据权重系统分配流量，并且可以根据实际负载情况调整权重系数。
- 最少连接数：服务消费者会选择连接数最少的一个服务提供者节点进行调用。
- 一致性 Hash：通过 Hash 算法将对象和服务提供者节点放在 Hash 环上，为对象选择对应的服务提供者节点
