---
title: 9.服务提供者调用真实方法的实现
date: 2024/6/09

---

## 🍈S

上一章节完成「服务提供者与服务消费者之间的数据交换」，那么之后该如何实现调用真实的方法呢？

我们要尽量屏蔽底层实现细节，仅仅用几行代码就能实现方法调用。

## 🍈T

本章，要实现的目标就是使 rpc 框架的服务提供者能够调用真实的方法，并且能够向服务消费者响应真实方法返回的结果数据。

<img src="https://doublew2w-myblogimages.oss-cn-hangzhou.aliyuncs.com/img/202406090035677.png"/>

难点在哪里？

- 怎么知道调用什么真实方法？
- 怎么构造请求参数
- 怎么构造返回消息

解决：

1. 根据相应的协议对必要的参数进行封装，利用「封装后的参数」去调用服务提供者，
2. 服务提供者接收到参数后，进行解析，找到对应的「。真实方法」，传递对应的「参数」
3. 「真实方法」执行后，返回响应给服务提供者。
4. 服务提供者根据协议封装响应，传递给服务消费者。

## 🍈A

<img src="https://doublew2w-myblogimages.oss-cn-hangzhou.aliyuncs.com/img/202406090043993.png"/>

服务提供者在启动时会去扫描标有 `@RpcService` 的类，并通过反射创建该类的实例，将该类实现的「接口名称#版本号#分组」作为 Key，这个「类的实例」作为 value 存放在一个 Map 集合中。



服务消费者在向服务提供者发起调用时，需要传递以下参数

- 要调用的真实方法所在的类名称。
- 要调用的真实方法的名称。
- 要调用的真实方法的参数类型数组。
- 要调用的真实方法的参数数组。
- 要调用的真实方法所在类的版本号，
- 要调用的真实方法所在类的分组。



```java
@Slf4j
public class RpcProviderHandler extends SimpleChannelInboundHandler<RpcProtocol<RpcRequest>> {
  private final Map<String, Object> handlerMap;

  public RpcProviderHandler(Map<String, Object> handlerMap) {
    this.handlerMap = handlerMap;
  }

  @Override
  protected void channelRead0(ChannelHandlerContext ctx, RpcProtocol<RpcRequest> msg)
      throws Exception {
    ServerThreadPool.submit(
        () -> {
          // 消息头
          RpcHeader header = msg.getHeader();
          header.setMsgType((byte) RpcType.RESPONSE.getType());
          log.debug("Receive request " + header.getRequestId());

          // 消息体
          RpcRequest request = msg.getBody();
          RpcProtocol<RpcResponse> responseRpcProtocol = new RpcProtocol<>();
          RpcResponse response = new RpcResponse();
          try {
            // 成功调用
            Object result = handle(request);
            response.setResult(result);
            response.setAsync(request.isAsync());
            response.setOneway(request.isOneway());
            header.setStatus((byte) RpcStatus.SUCCESS.getCode());
          } catch (Throwable t) {
            // 失败
            response.setError(t.toString());
            header.setStatus((byte) RpcStatus.FAIL.getCode());
            log.error("RPC Server handle request error", t);
          }
          // 返回
          responseRpcProtocol.setHeader(header);
          responseRpcProtocol.setBody(response);
          ctx.writeAndFlush(responseRpcProtocol)
              .addListener(
                  (ChannelFutureListener)
                      channelFuture ->
                          log.debug("Send response for request " + header.getRequestId()));
        });
  }

  @Override
  public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
    log.error("server caught exception", cause);
    ctx.close();
  }

  private Object handle(RpcRequest request) throws Throwable {
    // 构造key
    String serviceKey =
        RpcServiceHelper.buildServiceKey(
            request.getClassName(), request.getVersion(), request.getGroup());
    // 获取对应实例
    Object serviceBean = handlerMap.get(serviceKey);
    if (serviceBean == null) {
      throw new RuntimeException(
          StrUtil.format(
              "service not exist: {}:{}", request.getClassName(), request.getMethodName()));
    }

    Class<?> serviceClass = serviceBean.getClass();
    String methodName = request.getMethodName();
    Class<?>[] parameterTypes = request.getParameterTypes();
    Object[] parameters = request.getParameters();

    log.debug(serviceClass.getName());
    log.debug(methodName);
    if (parameterTypes != null && parameters.length > 0) {
      for (Class<?> parameterType : parameterTypes) {
        log.debug(parameterType.getName());
      }
    }

    if (parameters != null && parameters.length > 0) {
      for (Object parameter : parameters) {
        log.debug(parameter.toString());
      }
    }
    return invokeMethod(serviceBean, serviceClass, methodName, parameterTypes, parameters);
  }

  // TODO 目前使用JDK动态代理方式，此处埋点
  private Object invokeMethod(
      Object serviceBean,
      Class<?> serviceClass,
      String methodName,
      Class<?>[] parameterTypes,
      Object[] parameters)
      throws Throwable {
    log.info("Start invoking method...:");
    Method method = serviceClass.getMethod(methodName, parameterTypes);
    method.setAccessible(true);
    return method.invoke(serviceBean, parameters);
  }
}

```

在 Rpc 接口新建一个方法，进行实现。

```java
@RpcService(
    interfaceClass = DemoService.class,
    interfaceClassName = "com.doublew2w.rpc.test.provider.naive.DemoService",
    group = "double")
public class ProviderService implements DemoService {

  @Override
  public String helloWorld(String name) {
    return name + " hello world";
  }
}
```

## 🍈R

<img src="https://doublew2w-myblogimages.oss-cn-hangzhou.aliyuncs.com/img/202406090148156.png"/>
